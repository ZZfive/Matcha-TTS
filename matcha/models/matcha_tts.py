import datetime as dt
import math
import random

import torch

import matcha.utils.monotonic_align as monotonic_align  # pylint: disable=consider-using-from-import
from matcha import utils
from matcha.models.baselightningmodule import BaseLightningClass
from matcha.models.components.flow_matching import CFM
from matcha.models.components.text_encoder import TextEncoder
from matcha.utils.model import (
    denormalize,
    duration_loss,
    fix_len_compatibility,
    generate_path,
    sequence_mask,
)

log = utils.get_pylogger(__name__)


class MatchaTTS(BaseLightningClass):  # ğŸµ
    def __init__(
        self,
        n_vocab,
        n_spks,
        spk_emb_dim,
        n_feats,
        encoder,
        decoder,
        cfm,
        data_statistics,
        out_size,
        optimizer=None,
        scheduler=None,
        prior_loss=True,
        use_precomputed_durations=False,
    ):
        super().__init__()

        self.save_hyperparameters(logger=False)

        self.n_vocab = n_vocab
        self.n_spks = n_spks
        self.spk_emb_dim = spk_emb_dim
        self.n_feats = n_feats
        self.out_size = out_size
        self.prior_loss = prior_loss
        self.use_precomputed_durations = use_precomputed_durations

        if n_spks > 1:
            self.spk_emb = torch.nn.Embedding(n_spks, spk_emb_dim)

        self.encoder = TextEncoder(
            encoder.encoder_type,
            encoder.encoder_params,
            encoder.duration_predictor_params,
            n_vocab,
            n_spks,
            spk_emb_dim,
        )
        # åŸºäºFlow matchingçš„è§£ç å™¨
        self.decoder = CFM(
            in_channels=2 * encoder.encoder_params.n_feats,
            out_channel=encoder.encoder_params.n_feats,
            cfm_params=cfm,
            decoder_params=decoder,
            n_spks=n_spks,
            spk_emb_dim=spk_emb_dim,
        )

        self.update_data_statistics(data_statistics)

    @torch.inference_mode()
    def synthesise(self, x, x_lengths, n_timesteps, temperature=1.0, spks=None, length_scale=1.0):
        """
        Generates mel-spectrogram from text. Returns:
            1. encoder outputs
            2. decoder outputs
            3. generated alignment

        Args:
            x (torch.Tensor): batch of texts, converted to a tensor with phoneme embedding ids.
                shape: (batch_size, max_text_length)
            x_lengths (torch.Tensor): lengths of texts in batch.
                shape: (batch_size,)
            n_timesteps (int): number of steps to use for reverse diffusion in decoder.
            temperature (float, optional): controls variance of terminal distribution.
            spks (bool, optional): speaker ids.
                shape: (batch_size,)
            length_scale (float, optional): controls speech pace.
                Increase value to slow down generated speech and vice versa.

        Returns:
            dict: {
                "encoder_outputs": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Average mel spectrogram generated by the encoder
                "decoder_outputs": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Refined mel spectrogram improved by the CFM
                "attn": torch.Tensor, shape: (batch_size, max_text_length, max_mel_length),
                # Alignment map between text and mel spectrogram
                "mel": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Denormalized mel spectrogram
                "mel_lengths": torch.Tensor, shape: (batch_size,),
                # Lengths of mel spectrograms
                "rtf": float,
                # Real-time factor
            }
        """
        # For RTF computation
        t = dt.datetime.now()

        if self.n_spks > 1:
            # Get speaker embedding
            spks = self.spk_emb(spks.long())

        # Get encoder_outputs `mu_x` and log-scaled token durations `logw`
        mu_x, logw, x_mask = self.encoder(x, x_lengths, spks)

        w = torch.exp(logw) * x_mask  # å°†å¯¹æ•°æŒç»­æ—¶é—´è½¬ä¸ºå®é™…æŒç»­æ—¶é—´
        w_ceil = torch.ceil(w) * length_scale  # length_scaleç”¨äºæ§åˆ¶ç”ŸæˆéŸ³é¢‘çš„é€Ÿåº¦
        y_lengths = torch.clamp_min(torch.sum(w_ceil, [1, 2]), 1).long()  # è®¡ç®—æ¯ä¸ªæ ·æœ¬çš„melè°±å›¾é•¿åº¦ï¼Œæ‰€æœ‰é¢„æµ‹é•¿åº¦è‡³å°‘ä¸º1ï¼›å°±æ˜¯å°†æ¯æ¡æ–‡æœ¬éŸ³ç´ åºåˆ—ä¸­æ¯ä¸ªéŸ³ç´ å¯¹åº”çš„æŒç»­æ—¶é—´æ±‚å’Œï¼Œå°±æ˜¯æœ€ç»ˆé¢„æµ‹çš„melè°±å›¾é•¿åº¦
        y_max_length = y_lengths.max()  # è®¡ç®—æ‰€æœ‰æ ·æœ¬melè°±å›¾é•¿åº¦çš„æœ€å¤§å€¼
        y_max_length_ = fix_len_compatibility(y_max_length)  # ç¡®ä¿y_max_lengthæ˜¯2çš„å¹‚æ¬¡

        # Using obtained durations `w` construct alignment map `attn`
        y_mask = sequence_mask(y_lengths, y_max_length_).unsqueeze(1).to(x_mask.dtype)  # ä¸ºmelè°±å›¾æ„å»ºé•¿åº¦æ©ç   shape: [batch_size, 1, max_mel_length]ï¼Œå¦‚[1, 1, 848]
        attn_mask = x_mask.unsqueeze(-1) * y_mask.unsqueeze(2)  # ä¸ºæ–‡æœ¬å’Œmelè°±å›¾æ„å»ºæ³¨æ„åŠ›æ©ç   shape: [batch_size, 1, text_length, mel_length]ï¼Œå¦‚[1, 1, 311, 848]
        attn = generate_path(w_ceil.squeeze(1), attn_mask.squeeze(1)).unsqueeze(1)  # ä½¿ç”¨é¢„æµ‹çš„æŒç»­æ—¶é—´ç”Ÿæˆå•è°ƒå¯¹é½è·¯å¾„  shape: [batch_size, 1, text_length, mel_length]ï¼Œå¦‚[1, 1, 311, 848]

        # Align encoded text and get mu_yï¼›å°†æ³¨æ„åŠ›å›¾å’Œç¼–ç å™¨è¾“å‡ºç›¸ä¹˜å¾—åˆ°å¯¹é½åçš„ç‰¹å¾
        # attn.squeeze(1).transpose(1, 2): [batch_size, mel_length, text_length]
        # mu_x.transpose(1, 2): [batch_size, text_length, n_feats]
        # mu_y: [batch_size, mel_length, n_feats]ï¼Œå¦‚[1, 848, 80]
        mu_y = torch.matmul(attn.squeeze(1).transpose(1, 2), mu_x.transpose(1, 2))
        
        # è°ƒæ•´ç»´åº¦é¡ºåºï¼›shape: [batch_size, n_feats, mel_length]ï¼Œå¦‚[1, 80, 848]
        mu_y = mu_y.transpose(1, 2)
        # æˆªå–åˆ°å®é™…éœ€è¦çš„é•¿åº¦
        encoder_outputs = mu_y[:, :, :y_max_length]

        # Generate sample tracing the probability flowï¼›è¾“å‡ºshapeä¸å˜ï¼Œå¦‚[1, 80, 848]
        decoder_outputs = self.decoder(mu_y, y_mask, n_timesteps, temperature, spks)  # æ­¤å¤„çš„mu_yå°±æ˜¯é¢„æµ‹çš„åˆå§‹melè°±å›¾ï¼Œdecoderå†…éƒ¨æ˜¯CFMï¼Œé€šè¿‡FLow matchingå°†å…ˆéªŒåˆ†å¸ƒ(ä¸€èˆ¬æ˜¯æ ‡å‡†æ­£æ€åˆ†å¸ƒ)è½¬åŒ–ä¸ºæœ€ç»ˆçš„melè°±å›¾åˆ†å¸ƒï¼Œè¿™ä¸ªè¿‡ç¨‹ä¸­åŸºäºæ­¤å¤„é¢„æµ‹çš„melè°±å›¾æ„å»ºè¾“å…¥
        decoder_outputs = decoder_outputs[:, :, :y_max_length]  # æˆªå–åˆ°å®é™…éœ€è¦çš„é•¿åº¦ï¼Œ[1, 80, 845]

        t = (dt.datetime.now() - t).total_seconds()
        rtf = t * 22050 / (decoder_outputs.shape[-1] * 256)

        return {
            "encoder_outputs": encoder_outputs,
            "decoder_outputs": decoder_outputs,
            "attn": attn[:, :, :y_max_length],
            "mel": denormalize(decoder_outputs, self.mel_mean, self.mel_std),
            "mel_lengths": y_lengths,
            "rtf": rtf,
        }

    def forward(self, x, x_lengths, y, y_lengths, spks=None, out_size=None, cond=None, durations=None):
        """
        Computes 3 losses:
            1. duration loss: loss between predicted token durations and those extracted by Monotonic Alignment Search (MAS).
            2. prior loss: loss between mel-spectrogram and encoder outputs.
            3. flow matching loss: loss between mel-spectrogram and decoder outputs.

        Args:
            x (torch.Tensor): batch of texts, converted to a tensor with phoneme embedding ids.
                shape: (batch_size, max_text_length)
            x_lengths (torch.Tensor): lengths of texts in batch.
                shape: (batch_size,)  åŒä¸€ä¸ªbatchä¸­ä¸åŒtextçš„é•¿åº¦ä¸åŒ
            y (torch.Tensor): batch of corresponding mel-spectrograms.
                shape: (batch_size, n_feats, max_mel_length)
            y_lengths (torch.Tensor): lengths of mel-spectrograms in batch.
                shape: (batch_size,)
            out_size (int, optional): length (in mel's sampling rate) of segment to cut, on which decoder will be trained.
                Should be divisible by 2^{num of UNet downsamplings}. Needed to increase batch size.
            spks (torch.Tensor, optional): speaker ids.
                shape: (batch_size,)
        """
        if self.n_spks > 1:
            # Get speaker embedding
            spks = self.spk_emb(spks)

        # Get encoder_outputs `mu_x` and log-scaled token durations `logw`
        mu_x, logw, x_mask = self.encoder(x, x_lengths, spks)  # text encoderé¢„æµ‹
        y_max_length = y.shape[-1]

        y_mask = sequence_mask(y_lengths, y_max_length).unsqueeze(1).to(x_mask)
        attn_mask = x_mask.unsqueeze(-1) * y_mask.unsqueeze(2)

        if self.use_precomputed_durations:  # ä½¿ç”¨å¤–éƒ¨é¢„å…ˆè®¡ç®—å¥½çš„æŒç»­æ—¶é—´æ„å»ºæ—¶é—´è½¬ç§»è·¯å¾„
            attn = generate_path(durations.squeeze(1), attn_mask.squeeze(1))
        else:
            # Use MAS to find most likely alignment `attn` between text and mel-spectrogram
            with torch.no_grad():  # ä½¿ç”¨MASæœç´¢æŒç»­æ—¶é—´è½¬ç§»è·¯å¾„
                const = -0.5 * math.log(2 * math.pi) * self.n_feats
                factor = -0.5 * torch.ones(mu_x.shape, dtype=mu_x.dtype, device=mu_x.device)
                y_square = torch.matmul(factor.transpose(1, 2), y**2)
                y_mu_double = torch.matmul(2.0 * (factor * mu_x).transpose(1, 2), y)
                mu_square = torch.sum(factor * (mu_x**2), 1).unsqueeze(-1)
                log_prior = y_square - y_mu_double + mu_square + const

                attn = monotonic_align.maximum_path(log_prior, attn_mask.squeeze(1))
                attn = attn.detach()  # b, t_text, T_mel

        # Compute loss between predicted log-scaled durations and those obtained from MAS
        # refered to as prior loss in the paper
        logw_ = torch.log(1e-8 + torch.sum(attn.unsqueeze(1), -1)) * x_mask  # è®­ç»ƒè¿‡ç¨‹ä¸­è®¡ç®—éŸ³ç´ æŒç»­æ—¶é—´
        dur_loss = duration_loss(logw, logw_, x_lengths)  # è®¡ç®—æŒç»­æ—¶é—´æŸå¤±

        # Cut a small segment of mel-spectrogram in order to increase batch size
        #   - "Hack" taken from Grad-TTS, in case of Grad-TTS, we cannot train batch size 32 on a 24GB GPU without it
        #   - Do not need this hack for Matcha-TTS, but it works with it as well
        # ç›®çš„æ˜¯é€šè¿‡æˆªå–melé¢‘è°±å›¾(spectrogram)çš„ä¸€ä¸ªè¾ƒå°ç‰‡æ®µæ¥å‡å°‘å†…å­˜ä½¿ç”¨ï¼Œä»è€Œèƒ½å¤Ÿå¢åŠ è®­ç»ƒæ—¶çš„batch sizeã€‚è¿™ä¸ªæŠ€å·§æœ€åˆæ¥è‡ªGrad-TTSé¡¹ç›®ã€‚
        if not isinstance(out_size, type(None)):
            max_offset = (y_lengths - out_size).clamp(0)  # è®¡ç®—å¯ä»¥åç§»çš„æœ€å¤§å€¼ï¼šåŸå§‹é•¿åº¦å‡å»ç›®æ ‡é•¿åº¦ï¼Œå¹¶ç¡®ä¿éè´Ÿ
            offset_ranges = list(zip([0] * max_offset.shape[0], max_offset.cpu().numpy()))  # ä¸ºæ¯ä¸ªbatchæ ·æœ¬åˆ›å»ºåç§»èŒƒå›´(0åˆ°max_offset)
            out_offset = torch.LongTensor(
                [torch.tensor(random.choice(range(start, end)) if end > start else 0) for start, end in offset_ranges]
            ).to(y_lengths)  # ä¸ºæ¯ä¸ªbatchæ ·æœ¬éšæœºé€‰æ‹©ä¸€ä¸ªåç§»é‡
            attn_cut = torch.zeros(attn.shape[0], attn.shape[1], out_size, dtype=attn.dtype, device=attn.device)  # åˆ›å»ºæ–°çš„æˆªå–åçš„å¼ é‡
            y_cut = torch.zeros(y.shape[0], self.n_feats, out_size, dtype=y.dtype, device=y.device)

            y_cut_lengths = []
            for i, (y_, out_offset_) in enumerate(zip(y, out_offset)):
                y_cut_length = out_size + (y_lengths[i] - out_size).clamp(None, 0)  # è®¡ç®—å®é™…æˆªå–é•¿åº¦
                y_cut_lengths.append(y_cut_length)
                cut_lower, cut_upper = out_offset_, out_offset_ + y_cut_length  # è®¡ç®—æˆªå–èŒƒå›´ï¼Œå³æˆªå–çš„èµ·å§‹å’Œç»“æŸä½ç½®
                y_cut[i, :, :y_cut_length] = y_[:, cut_lower:cut_upper]  # æˆªå–melé¢‘è°±å›¾
                attn_cut[i, :, :y_cut_length] = attn[i, :, cut_lower:cut_upper]  # æˆªå–æ³¨æ„åŠ›å›¾

            y_cut_lengths = torch.LongTensor(y_cut_lengths)  # å°†å®é™…æˆªå–é•¿åº¦è½¬æ¢ä¸ºLongTensor
            y_cut_mask = sequence_mask(y_cut_lengths).unsqueeze(1).to(y_mask)  # åˆ›å»ºæˆªå–åçš„æ©ç 

            attn = attn_cut  # ä½¿ç”¨æˆªå–åçš„æ³¨æ„åŠ›å›¾
            y = y_cut  # ä½¿ç”¨æˆªå–åçš„melé¢‘è°±å›¾
            y_mask = y_cut_mask  # ä½¿ç”¨æˆªå–åçš„æ©ç 

        # Align encoded text with mel-spectrogram and get mu_y segment
        mu_y = torch.matmul(attn.squeeze(1).transpose(1, 2), mu_x.transpose(1, 2))
        mu_y = mu_y.transpose(1, 2)  # mu_yå°±æ˜¯ç»è¿‡æ—¶é—´é•¿åº¦å¯¹é½åçš„é¢„æµ‹melè°±å›¾

        # Compute loss of the decoder
        diff_loss, _ = self.decoder.compute_loss(x1=y, mask=y_mask, mu=mu_y, spks=spks, cond=cond)

        if self.prior_loss:
            # æ­¤å…ˆéªŒæŸå¤±å‡è®¾ç›®æ ‡yæœä»å‡å€¼ä¸ºmu_yï¼Œæ–¹å·®ä¸º1çš„æ­£æ€åˆ†å¸ƒ
            # æœ€å°åŒ–è´Ÿå¯¹æ•°ä¼¼ç„¶å°±æ˜¯æœ€å¤§åŒ–è§‚æµ‹æ•°æ®çš„æ¦‚ç‡ï¼›å³p(y|Î¼) = 1/âˆš(2Ï€) * exp(-(y-Î¼)Â²/2)->-log p(y|Î¼) = (y-Î¼)Â²/2 + 0.5*log(2Ï€)
            prior_loss = torch.sum(0.5 * ((y - mu_y) ** 2 + math.log(2 * math.pi)) * y_mask)  # åº”ç”¨æ©ç æ±‚å’Œ
            prior_loss = prior_loss / (torch.sum(y_mask) * self.n_feats)  # å½’ä¸€åŒ–
        else:
            prior_loss = 0

        return dur_loss, prior_loss, diff_loss, attn
